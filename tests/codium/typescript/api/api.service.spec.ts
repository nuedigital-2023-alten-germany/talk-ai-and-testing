// Generated by CodiumAI

import { ApiService } from "../../../../src/typescript/api/api.service";

/*
Code Analysis

Main functionalities:
The ApiService class is responsible for fetching data from an external API. It has two main functionalities: fetchAll() which retrieves all users from the API and fetchOne(id) which retrieves a single user by their id.

Methods:
- fetchAll(): retrieves all users from the API and returns a Promise of an array of User objects.
- fetchOne(id): retrieves a single user by their id and returns a Promise of a User object.
- executeRequest(path): a private method that executes the actual HTTP request to the API. It takes a path parameter and returns a Promise of type T, which is inferred based on the type of data being requested.

Fields:
- baseUrl: a private readonly field that holds the base URL of the external API. It is set to "https://jsonplaceholder.typicode.com".

*/

describe("ApiService_class", () => {
  // Tests that fetchAll() returns an array of users
  it("test_fetch_all_returns_array_of_users", async () => {
    const apiService = new ApiService();
    const users = await apiService.fetchAll();
    expect(Array.isArray(users)).toBe(true);
    expect(users.length).toBeGreaterThan(0);
    expect(users[0]).toHaveProperty("id");
    expect(users[0]).toHaveProperty("name");
    expect(users[0]).toHaveProperty("username");
    expect(users[0]).toHaveProperty("email");
    expect(users[0]).toHaveProperty("address");
    expect(users[0]).toHaveProperty("phone");
    expect(users[0]).toHaveProperty("website");
    expect(users[0]).toHaveProperty("company");
  });

  // Tests that fetchOne(id) returns a single user object
  it("test_fetch_one_returns_single_user_object", async () => {
    const apiService = new ApiService();
    const user = await apiService.fetchOne(1);
    expect(user).toHaveProperty("id");
    expect(user).toHaveProperty("name");
    expect(user).toHaveProperty("username");
    expect(user).toHaveProperty("email");
    expect(user).toHaveProperty("address");
    expect(user).toHaveProperty("phone");
    expect(user).toHaveProperty("website");
    expect(user).toHaveProperty("company");
  });

  // Tests that executeRequest(path) returns the expected data
  it("test_execute_request_returns_expected_data", async () => {
    const apiService = new ApiService();
    const data = await apiService.executeRequest<User[]>("users");
    expect(Array.isArray(data)).toBe(true);
    expect(data.length).toBeGreaterThan(0);
    expect(data[0]).toHaveProperty("id");
    expect(data[0]).toHaveProperty("name");
    expect(data[0]).toHaveProperty("username");
    expect(data[0]).toHaveProperty("email");
    expect(data[0]).toHaveProperty("address");
    expect(data[0]).toHaveProperty("phone");
    expect(data[0]).toHaveProperty("website");
    expect(data[0]).toHaveProperty("company");
  });

  // Tests that executeRequest(path) throws an error for non-existent paths
  it("test_execute_request_throws_error_for_non_existent_paths", async () => {
    const apiService = new ApiService();
    await expect(
      apiService.executeRequest("non-existent-path")
    ).rejects.toThrow();
  });

  // Tests that executeRequest(path) throws an error for non-200 response codes
  it("test_execute_request_throws_error_for_non_200_response_codes", async () => {
    const apiService = new ApiService();
    await expect(apiService.executeRequest("posts/1")).rejects.toThrow();
  });

  // Tests that executeRequest(path) handles network errors
  it("test_execute_request_handles_network_errors", async () => {
    const apiService = new ApiService();
    const mockExecuteRequest = jest
      .spyOn(apiService, "executeRequest")
      .mockImplementation(() => {
        throw new Error("Network error");
      });
    await expect(apiService.executeRequest("users")).rejects.toThrow(
      "Network error"
    );
    mockExecuteRequest.mockRestore();
  });

  // Tests that executeRequest(path) returns a rejected promise for errors
  it("test_execute_request_returns_rejected_promise_for_errors", async () => {
    const apiService = new ApiService();
    const mockExecuteRequest = jest
      .spyOn(apiService, "executeRequest")
      .mockImplementation(() => {
        throw new Error("Some error");
      });
    await expect(apiService.executeRequest("users")).rejects.toThrow(
      "Some error"
    );
    mockExecuteRequest.mockRestore();
  });

  // Tests that baseUrl is set correctly
  it("test_base_url_is_set_correctly", () => {
    const apiService = new ApiService();
    expect(apiService["baseUrl"]).toBe("https://jsonplaceholder.typicode.com");
  });

  // Tests that executeRequest(path) handles non-JSON response data
  it("test_execute_request_handles_non_json_response_data", async () => {
    const apiService = new ApiService();
    const mockResponse = { ok: true, text: () => Promise.resolve("not json") };
    const mockFetch = jest
      .spyOn(global, "fetch")
      .mockResolvedValue(mockResponse as any);
    await expect(apiService.executeRequest("users")).rejects.toThrow();
    mockFetch.mockRestore();
  });

  // Tests that executeRequest(path) handles empty response data
  it("test_execute_request_handles_empty_response_data", async () => {
    const apiService = new ApiService();
    const mockResponse = { ok: true, json: () => Promise.resolve(null) };
    const mockFetch = jest
      .spyOn(global, "fetch")
      .mockResolvedValue(mockResponse as any);
    await expect(apiService.executeRequest("users")).rejects.toThrow();
    mockFetch.mockRestore();
  });

  // Tests that executeRequest(path) returns a rejected promise for network errors
  it("test_execute_request_returns_rejected_promise_for_network_errors", async () => {
    const apiService = new ApiService();
    const mockFetch = jest
      .spyOn(global, "fetch")
      .mockRejectedValue(new Error("Network error"));
    await expect(apiService.executeRequest("users")).rejects.toThrow(
      "Network error"
    );
    mockFetch.mockRestore();
  });

  // Tests that executeRequest(path) returns a rejected promise for non-200 response codes
  it("test_execute_request_returns_rejected_promise_for_non_200_response_codes", async () => {
    const apiService = new ApiService();
    const mockResponse = { ok: false, statusText: "Not Found" };
    const mockFetch = jest
      .spyOn(global, "fetch")
      .mockResolvedValue(mockResponse as any);
    await expect(apiService.executeRequest("users")).rejects.toThrow(
      "Not Found"
    );
    mockFetch.mockRestore();
  });
});
