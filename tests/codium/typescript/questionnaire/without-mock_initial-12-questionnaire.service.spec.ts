// Generated by CodiumAI

import { QuestionnaireService } from "../../../../src/typescript/questionnaire/questionnaire.service";



/*
Code Analysis

Main functionalities:
The QuestionnaireService class is responsible for managing the state of a questionnaire, including the current question, the user's answers, and the question map. It allows the user to answer questions, retrieve the current question, and get the answers submitted so far. The class also handles the logic for determining the next question based on the user's answer.

Methods:
- getCurrentQuestion(): returns the current question object
- setCurrentQuestionId(id: string): sets the current question ID
- getCurrentQuestionId(): returns the current question ID
- getQuestionMap(): returns the question map object
- answerQuestion(questionId: string, answerValue: string): records the user's answer and determines the next question
- getAnswers(): returns the answers submitted so far

Fields:
- currentQuestionId: the ID of the current question
- questionMap: a map of all the questions in the questionnaire
- answers: a map of the user's answers, with question IDs as keys and answer values as values
*/



describe('QuestionnaireService_class', () => {

    // Tests that getCurrentQuestion returns the first question if no current question id is set
    it('test_get_current_question_returns_first_question_if_no_current_question_id_is_set', () => {
      const questionnaire = {
        id: '1',
        questions: [
          {
            id: '1.1',
            type: 'text',
            text: 'Question 1.1',
            answers: [],
          },
          {
            id: '1.2',
            type: 'text',
            text: 'Question 1.2',
            answers: [],
          },
        ],
      };
      const service = new QuestionnaireService(questionnaire);

      expect(service.getCurrentQuestion()).toEqual(questionnaire.questions[0]);
    });
    // TODO: typisierung falsch, man muss hier nachbessern damit der Code keinen Fehler wirft
    // TODO: Testfall haben wir auch.
    // TODO: Ist etwas minimalistischer geschrieben
    //TODO: Die Testdaten werden für jeden Fall individuell angelegt (Kein beforeeach o.ä.)


    // Tests that getCurrentQuestion returns the current question if the current question id is set
    it('test_get_current_question_returns_current_question_if_current_question_id_is_set', () => {
      const questionnaire = {
        id: '1',
        questions: [
          {
            id: '1.1',
            type: 'text',
            text: 'Question 1.1',
            answers: [],
          },
          {
            id: '1.2',
            type: 'text',
            text: 'Question 1.2',
            answers: [],
          },
        ],
      };
      const service = new QuestionnaireService(questionnaire);
      service.setCurrentQuestionId('1.2');

      expect(service.getCurrentQuestion()).toEqual(questionnaire.questions[1]);
    });
    // TODO: typisierung falsch, man muss hier nachbessern damit der Code keinen Fehler wirft
    // TODO: Testfall haben wir auch

    // Tests that setCurrentQuestionId sets the current question id
    it('test_set_current_question_id_sets_the_current_question_id', () => {
      const questionnaire = {
        id: '1',
        questions: [
          {
            id: '1.1',
            type: 'text',
            text: 'Question 1.1',
            answers: [],
          },
          {
            id: '1.2',
            type: 'text',
            text: 'Question 1.2',
            answers: [],
          },
        ],
      };
      const service = new QuestionnaireService(questionnaire);
      service.setCurrentQuestionId('1.2');

      expect(service.getCurrentQuestionId()).toEqual('1.2');
    });
    // TODO: typisierung falsch, man muss hier nachbessern damit der Code keinen Fehler wirft
    // TODO: Diesen Test haben wir auch

    // Tests that getQuestionMap returns the question map
    it('test_get_question_map_returns_the_question_map', () => {
      const questionnaire = {
        id: '1',
        questions: [
          {
            id: '1.1',
            type: 'text',
            text: 'Question 1.1',
            answers: [],
          },
          {
            id: '1.2',
            type: 'text',
            text: 'Question 1.2',
            answers: [],
          },
        ],
      };
      const service = new QuestionnaireService(questionnaire);

      expect(service.getQuestionMap()).toEqual({ '1.1': questionnaire.questions[0], '1.2': questionnaire.questions[1] });
    });
    // TODO: typisierung falsch, man muss hier nachbessern damit der Code keinen Fehler wirft
    // TODO: Diesen Test haben wir auch
    // TODO: Wenn man before Hooks benutzt sollte man hier nicht mit questionnaire.question[0] arbeiten da unleserlich

    // Tests that answerQuestion updates answers and sets the current question id to the next question id
    it('test_answer_question_updates_answers_and_sets_current_question_id_to_next_question_id', () => {
      const questionnaire = {
        id: '1',
        questions: [
          {
            id: '1.1',
            type: 'text',
            text: 'Question 1.1',
            answers: [
              { value: 'yes', next: '1.2' },
              { value: 'no', next: '1.3' },
            ],
          },
          {
            id: '1.2',
            type: 'text',
            text: 'Question 1.2',
            answers: [],
          },
          {
            id: '1.3',
            type: 'text',
            text: 'Question 1.3',
            answers: [],
          },
        ],
      };
      const service = new QuestionnaireService(questionnaire);

      expect(service.answerQuestion('1.1', 'yes')).toEqual('1.2');
      expect(service.getAnswers()).toEqual({ '1.1': 'yes' });
    });
    // TODO: typisierung falsch, man muss hier nachbessern damit der Code keinen Fehler wirft
    // TODO: Haben wir auch nur in getrennten Testfällen
    // TODO: Answers können so nicht gebaut werden, die property 'text' fehlt
    // TODO: property 'text' fehlt in testdaten

    // Tests that getAnswers returns the answers
    it('test_get_answers_returns_the_answers', () => {
      const questionnaire = {
        id: '1',
        questions: [
          {
            id: '1.1',
            type: 'text',
            text: 'Question 1.1',
            answers: [],
          },
          {
            id: '1.2',
            type: 'text',
            text: 'Question 1.2',
            answers: [],
          },
        ],
      };
      const service = new QuestionnaireService(questionnaire);
      service.answerQuestion('1.1', 'yes');

      expect(service.getAnswers()).toEqual({ '1.1': 'yes' });
    });
    // TODO: typisierung falsch, man muss hier nachbessern damit der Code keinen Fehler wirft
    // TODO: Wurde im Test oben bereits getestet, darum wiederhohlung
    // TODO: Nonsense, hier fehlen answers!

    // Tests that getCurrentQuestion throws an error if there are no questions in the questionnaire
    it('test_get_current_question_throws_error_if_no_questions_in_questionnaire', () => {
      const questionnaire = {
        id: '1',
        questions: [],
      };
      const service = new QuestionnaireService(questionnaire);

      expect(() => service.getCurrentQuestion()).toThrowError('Questionnaire has no questions');
    });
    // TODO: typisierung falsch, man muss hier nachbessern damit der Code keinen Fehler wirft
    // TODO: Diesen Testfall haben wir auch
    // TODO: Der Fehler wird nicht geworfen, hier müsste undefined zurückkommen
    // TODO: Test Fehlerhaft, diese Fehlermeldung existiert nicht

    // Tests that getNextQuestionId throws an error if the answer value is not found and there is no next question id
    it('test_get_next_question_id_throws_error_if_answer_value_not_found_and_no_next_question_id', () => {
      const questionnaire = {
        id: '1',
        questions: [
          {
            id: '1.1',
            type: 'text',
            text: 'Question 1.1',
            answers: [
              { value: 'yes', next: '1.2' },
              { value: 'no', next: '1.3' },
            ],
          },
          {
            id: '1.2',
            type: 'text',
            text: 'Question 1.2',
            answers: [],
          },
          {
            id: '1.3',
            type: 'text',
            text: 'Question 1.3',
            answers: [],
          },
        ],
      };
      const service = new QuestionnaireService(questionnaire);

      expect(() => service.answerQuestion('1.1', 'invalid')).toThrowError('Question 1.1 has no answer with value invalid');
    });
    // TODO: typisierung falsch, man muss hier nachbessern damit der Code keinen Fehler wirft
    // TODO: Diesen Test haben wir auch
    // TODO: wird richtig überprüft
    // TODO: property 'text' fehlt in Testdaten

    // Tests that removeLaterAnswers deletes answers for later questions
    it('test_remove_later_answers_deletes_answers_for_later_questions', () => {
      const questionnaire = {
        id: '1',
        questions: [
          {
            id: '1.1',
            type: 'text',
            text: 'Question 1.1',
            answers: [],
          },
          {
            id: '1.2',
            type: 'text',
            text: 'Question 1.2',
            answers: [],
          },
          {
            id: '1.3',
            type: 'text',
            text: 'Question 1.3',
            answers: [],
          },
        ],
      };
      const service = new QuestionnaireService(questionnaire);
      service.answerQuestion('1.1', 'yes');
      service.answerQuestion('1.2', 'no');

      expect(service.getAnswers()).toEqual({ '1.1': 'yes', '1.2': 'no' });

      service.answerQuestion('1.1', 'no');

      expect(service.getAnswers()).toEqual({ '1.1': 'no' });
    });
    // TODO: typisierung falsch, man muss hier nachbessern damit der Code keinen Fehler wirft
    // TODO: Test an sich gut
    // TODO: Testdaten falsch! Hier fehlen Answers!

    // Tests that buildQuestionMap creates a question map from the questionnaire
    it('test_build_question_map_creates_question_map_from_questionnaire', () => {
      const questionnaire = {
        id: '1',
        questions: [
          {
            id: '1.1',
            type: 'text',
            text: 'Question 1.1',
            answers: [],
          },
          {
            id: '1.2',
            type: 'text',
            text: 'Question 1.2',
            answers: [],
          },
        ],
      };
      const service = new QuestionnaireService(questionnaire);

      expect(service.getQuestionMap()).toEqual({ '1.1': questionnaire.questions[0], '1.2': questionnaire.questions[1] });
    });
    // TODO: typisierung falsch, man muss hier nachbessern damit der Code keinen Fehler wirft
    // TODO: selber test wie in Zeile 115, wiederhohlung

    // Tests that getNextQuestionId sets the current question id to the first question if no current question id is set
    it('test_get_next_question_id_sets_current_question_id_to_first_question_if_no_current_question_id_is_set', () => {
      const questionnaire = {
        id: '1',
        questions: [
          {
            id: '1.1',
            type: 'text',
            text: 'Question 1.1',
            answers: [],
          },
          {
            id: '1.2',
            type: 'text',
            text: 'Question 1.2',
            answers: [],
          },
        ],
      };
      const service = new QuestionnaireService(questionnaire);

      expect(service.getNextQuestionId(null, '')).toEqual('1.1');
    });
    // TODO: typisierung falsch, man muss hier nachbessern damit der Code keinen Fehler wirft
    // TODO: Testet fälschlicherweise eine private Methode
    // TODO: falsche typisierung
    // TODO: Test ist nonsense
});
